# ✏️ Load Balancing (로드 밸런싱)

---

<img src="https://nesoy.github.io/assets/posts/20180602/1.png" width="70%" />

Client가 1명 또는 2명인 경우에는 Server에서 아주 여유롭게 사용자가 원하는 결과를 응답해줄 수 있습니다.

**하지만 Client가 한두명이 아니라 수천만명, 1억명이라면?**

<img src="https://nesoy.github.io/assets/posts/20180602/2.png" width="50%" />

서버에서는 모든 사람들의 응답을 처리해주려고 노력하지만 결국에는 지치게 되어 동작을 멈추게 될 겁니다.

그렇다면 위의 문제를 해결하기 위해서는 어떻게 해야할까요?

- `Scale-Up`: 서버가 더 빠르게 동작하기 위해서 하드웨어 성능을 올리는 방법
- `Scale-Out`: 하나의 서버보다는 여러대의 서버가 나눠서 일을 하는 방법

Scale-Out의 장점으로는...

- 하드웨어 향상하는 비용보다 서버 한대 추가 비용이 더 적습니다.
- 여러대의 서버 덕분에 무중단 서비스를 제공할 수 있습니다.

이렇게 여러대의 서버에 균등하게 트리팩을 분산시켜주는 역할을 하는 것이 `Load Balancer`입니다.

### 1. Load Balancing이란?

> 하나의 인터넷 서비스가 발생하는 트리팩이 많을 때 여러대의 서버가 분산처리해서 서버의 로드율 증가, 부하량, 속도저하 등을 고려해서 적절히 분산처리해서 해결해주는 서비스입니다.

<br>

### 2. Load Balncer의 기본 동작 방식

1. 클라이언트의 브라우저에서 www.naver.com 입력
2. 클라이언트에 설정된 메인 DNS 서버로 www.naer.com의 IP주소를 문의
3. 메인 DNS 서버는 네이버 주소를 관리하는 별도의 DNS 서버에 IP주소를 문의
4. 별도 관리 DNS 서버는 로드밸런서의 IP주소(가상 IP주소)를 메인 DNS 서버에게 알려줌
5. 메인 DNS 서버는 획득한 Virtual IP주소를 클라이언트에게 전송
6. 클라이언트에서 로드밸런서의 Virtual IP주소로 HTTP 요청
7. 로드밸런서는 별도 로드밸런싱 방법(ex. 라운드 로빈)을 통해 서버에게 요청을 전송
8. 서버의 작업 결과를 받은 로드밸런서는 전달받은 HTTP 결과를 클라이언트에게 전송

### 3. Load Balancing의 주요 기능

- `Health Check`: 기본적으로 보통의 로드밸런서는 서버들에 대한 주기적인 Health-Check를 통해 서버들의 장애 여부를 판단할 수 있습니다. 이로 인해 로드밸런서가 있을 때 서버 몇 대에 이상이 생기더라도 다른 정상 동작중인 서버로 트래픽을 보내주는 Fail-Over가 가능하고 또한 TCP/UDP 분석이 가능하기 때문에 방화벽 역할도 수행할 수 있습니다.
- `NAT(Network Address Translation)`: 사설 IP주소를 공인 IP주소로 바꾸는데 사용하는 통신망의 주소 변조기입니다. 반대로도 변경이 가능합니다. 추가로 이렇게 하게 되면 부족한 공인 IP주소를 효율적으로 사용할 수 있지만 로드밸런싱 관점에서는 여러개의 호스트가 하나의 공인IP를 통해 접속하는 것이 주 목적입니다.
  - `SNAT(Source Network Address Translation)`: 내부에서 외부로 트래픽이 나가는 경우 내부 사설 IP주소를 외부의 공인 IP주소로 변환하는 방식입니다. 집에서 사용하는 공유기가 대표적입니다.
  - `DNAT(Destination Network Access Translation)`: 외부에서 내부로 트래픽이 들어오는 경우 외부 공인IP 주소를 내부 사설IP 주소로 변환하는 방식입니다. 로드밸런서가 대표적입니다.
- `Tunneling`
  - 인터넷상에서 눈에 보이지 않는 통로를 만들어 통신할 수 있게하는 개념
  - 클라이언트와 서버 간 중간에서 터널링을 제공합니다.
  - 연결된 상호 간에만 캡슐화된 패킷을 구별해 캡슐화를 해제하게 합니다.
- `DSR(Dynamic Source Routing Protocol)`: 서버에서 클라이언트로 되돌아가는 경우, 목적지를 클라이언트로 설정한 다음 네트워크 장비나 로드밸런서를 거치지 않고 바로 클라이언트를 찾아가는 방식입니다. 이렇게 되면 로드밸런서의 부하를 줄여줄 수 있다는 장점이 있습니다.

<img src="https://nesoy.github.io/assets/posts/img/2019-07-10-16-39-38.png" />

<br>

### 4. Load Balancing의 종류

#### L2와 L3 로드밸런싱

- L2는 `MAC 주소`를, L3는 `IP주소`를 바탕으로 Load Balancing 합니다.

#### L4 로드밸런싱

L4 로드밸런서는 네트워크 계층(IP) 또는 Transport 계층(TCP/UDP)의 정보를 바탕으로 로드를 분산합니다. 즉, IP주소나 포트번호, MAC 주소 및 전송 프로토콜 등에 따라 트래픽을 나누고 분산처리 하는것이 가능합니다.

L4 로드밸런싱에는 다음과 같은 방법들이 있습니다.

- `Round Robin`: 세션을 각 서버에 순차적으로 맺어주는 방식입니다. 단순히 순서에 따라 세션을 할당하기 때문에 경우에 따라 경로별로 같은 처리량이 보장되지는 않습니다.
- `Least Connections`: 가장 적은 세션을 가진 서버로 트래픽을 보내는 방식입니다. 보편적으로 가장 많이 사용되는 방식이라고 합니다.
- `Hash 기반`: 특정 클라이언트는 특정 서버로만 할당시키는 방식입니다. 예를 들어 특정 IP주소 혹은 포트의 클라이언트들은 특정 서버로만 세션이 맺어지도록 하는 것입니다. 경로가 보장되고 접속자 수가 많을수록 분산 및 효율이 뛰어나다고 합니다.
- 이 외에도 `응답시간 기반`, `대역폭 기반` 등이 있습니다.

#### L7 로드밸런싱

L7은 L4를 포함하는 것 뿐만 아니라 OSI 7계층의 프로토콜을 바탕으로도 분산처리가 가능합니다. 예를 들어 온라인 쇼핑몰의 장바구니에 물건을 담아놨는데 다른 서버에서의 처리는 어려울 것입니다.

L7에는 다음과 같은 방법들이 있습니다.

- `URL Switching`: 특정 하위 URL들은 특정 서버로 처리하는 방식입니다. 예를 들어 `../kanguk/image`와 같은 특정 URL을 가진 주소들은 서버가 아닌 별도의 스토리지에 있는 객체 데이터로 바로 연결되도록 구성할 수 있습니다.
- `Context Switching`: 클라이언트가 요청한 특정 리소스에 대해 특정 서버 등으로 연결해줄 수 있습니다. 예를 들어 이미지 파일에 대해서는 확장자를 참조해서 별도의 구성된 이미지 파일이 있는 서버 또는 스토리지로 직접 연결해줄 수 있습니다.
- `쿠키 지속성(Persistence with Cookie)`: 쿠키 정보를 바탕으로 클라이언트가 연결했었던 동일한 서버에 계속 할당해주는 방식입니다. 특히 사설 네트워크에 있던 클라이언트의 IP주소가 공인IP로 치환되어 전송하는 방식을 지원합니다. `(X-Forwarded-For 헤더에 클라이언트 IP주소를 별도로 기록)`

<br>

### 5. Load Balancer 장애 대비

<img src="https://nesoy.github.io/assets/posts/20180602/8.gif" />

- Load Balancer를 이중화해서 장애를 대비할 수 있습니다.
- 이중화된 로드밸런서는 서로 Health-Check를 진행하게 됩니다.
- 메인 로드밸런서가 동작하지 않으면 가상IP는 여분의 로드밸런서로 변경됩니다.
- 변경되면 여분의 로드밸런서로 운영이 됩니다.

---

### Reference

- https://nesoy.github.io/articles/2018-06/Load-Balancer
- https://www.stevenjlee.net/2020/06/30/%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%98-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-load-balancing-%EA%B7%B8/
