# ✏️ Merge Sort (병합 정렬)

---

이번 포스팅에서는 분할-정복 알고리즘 중 하나인 병합 정렬에 대해서 알아보겠습니다!

> 분할-정복 알고리즘 (Divide and Conquer Algorithm) <br>
>
> 해결할 수 없는 문제를 작게 쪼개서(분할) 풀어나가는(정복) 것입니다. 작은 문제를 해결해서 큰 문제를 해결해 나가는 알고리즘으로 재귀함수를 통해 자연스럽게 구현할 수 있습니다.

### 1. 합병 정렬이란?

합병 정렬은 `정렬되지 않은 리스트를 1개만 남을 때까지 반으로 분할한 다음 나눠진 리스트들을 서로 비교하면서 합쳐가는 정렬 방식` 입니다.

<br>

### 2. 합병 정렬 과정

**예를 들어 다음과 같이 1부터 8까지 총 8개의 숫자가 들어있는 배열이 있다고 가정해보겠습니다.**

```
[6, 5, 3, 1, 8, 7, 2, 4]
```

**먼저 하나의 배열을 두 덩어리로 쪼갭니다.**

```
[6, 5, 3, 1] [8, 7, 2, 4]
```

**그리고 다시 2개의 배열을 4개로 쪼갭니다.**

```
[6, 5] [3, 1] [8, 7] [2, 4]
```

**마지막으로 4개의 배열을 8개로 쪼갭니다.**

```
[6] [5] [3] [1] [8] [7] [2] [4]
```

**현 시점에서는 더 이상 쪼갤 수 없기 때문에 합치는 과정을 진행합니다. `합칠 때는 작은 숫자가 앞에 그리고 큰 숫자를 뒤에 위치시킵니다`.**

```
[5, 6] [1, 3] [7, 8] [2, 4]
```

**이제 4개의 배열을 2개로 합칩니다. `각 배열 내에서 가장 작은값 2개를 비교해서 더 작은 값을 먼저 선택하면 자연스럽게 크기 순으로 선택이 됩니다`.**

```
[1, 3, 5, 6] [2, 4, 7, 8]
```

**마찬가지로 크기 순으로 선택해가면서 합치게 되면 최종 배열을 얻을 수 있습니다.**

```
[1, 2, 3, 4, 5, 6, 7, 8]
```

<br>

### 3. 합병 정렬의 시간복잡도

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FynXy1%2FbtqAVHy0H31%2FrYilueKaepty9q8EbNARa1%2Fimg.png" style="background-color: white"/>

배열의 원소 개수 n이 2의 거듭제곱이라고 가정해보겠습니다.

만약 n이 2의 세제곱인 8이라고 한다면 배열의 크기가 `2^3 -> 2^2 -> 2^1 -> 2^0`으로 줄게 되어서 깊이가 3이 됩니다. 3번을 나눈다고 생각하시면 됩니다.

> 결론적으로 n = 2^k라고 가정한다면 나누는 횟수는 k번이라고 생각하면 됩니다. 따라서 k는 log2n 이 됩니다. <br>(밑이 2인 로그입니다)

나눈 횟수만큼 병합 단계가 필요하게 됩니다. 그렇다면 각 병합 단계에서 비교연산은 얼마나 수행될까?

> - 크기가 1인 부분배열 2개를 병합할 때는 최대 2번의 비교 연산이 필요합니다. 그리고 부분배열의 쌍이 4개이기 때문에 총 2 X 4인 최대 8번의 비교연산이 필요합니다.
> - 다음 단계에서 크기가 2인 부분배열 2개를 병합하는 데 최대 4번의 비교연산이 필요하고 부분배열의 쌍이 2개이기 때문에 4 X 2인 최대 8번의 비교연산이 필요합니다.
> - 마지막 단계에서는 크기가 4인 부분배열 2개를 병합하는 데 최대 8번의 비교연산이 필요하고 부분배열의 쌍이 1개이기 때문에 8 X 1인 8번의 비교연산이 필요합니다.
> - 이것을 일반화하면 하나의 합병 단계에서는 최대 N번의 비교연산을 수행함을 알 수 있습니다.

`따라서 시간복잡도는 O(NlogN)이 됩니다.`

<br>

### 4. 합병 정렬의 장단점

#### 장점

- 안정적인 정렬 방법이고 데이터의 분포에 영향을 덜 받습니다.
- 입력 데이터가 무엇이든간에 정렬되는 시간은 동일합니다.
- 최악, 평균, 최선의 경우가 다 같이 `O(NlogN)`인 정렬 방법입니다.

#### 단점

- `임시 배열`이 필요합니다.
- 배열의 크기가 큰 경우에는 이동 횟수가 많아서 매우 큰 시간적 낭비를 합니다.
  - 하지만 만약 연결리스트로 구현해서 합병정렬을 진행한다면 링크 인덱스만 변경되기 때문에 데이터의 이동은 무시할 수 있을 정도로 작아지게 됩니다.
- 따라서 크기가 큰 레코드를 정렬할 경우에는 `연결리스트`를 사용해서 더욱 효율적으로 구현할 수 있습니다.

<img src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbv9Ykq%2FbtqAYG6jfkq%2FycPEGCdw2RzAKKmBNRZ3f0%2Fimg.png' style="background-color: white"/>

---

### Reference

**이미지 출처**

- https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html
- https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html

**참고 자료**

- https://devlog-wjdrbs96.tistory.com/56
- https://www.daleseo.com/sort-merge/
- https://fomaios.tistory.com/entry/Algorithm-%ED%95%A9%EB%B3%91-%EC%A0%95%EB%A0%ACMerge-Sort%EB%9E%80-feat-Swift
